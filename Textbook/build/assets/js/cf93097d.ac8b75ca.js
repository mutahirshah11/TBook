"use strict";(globalThis.webpackChunkbook=globalThis.webpackChunkbook||[]).push([[52],{2735(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"part4/chapter-16-sim-to-real","title":"Chapter 16: Sim-to-Real Transfer Techniques","description":"The Reality Gap","source":"@site/docs/part4/chapter-16-sim-to-real.md","sourceDirName":"part4","slug":"/part4/chapter-16-sim-to-real","permalink":"/docs/part4/chapter-16-sim-to-real","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/part4/chapter-16-sim-to-real.md","tags":[],"version":"current","sidebarPosition":16,"frontMatter":{"sidebar_label":"Chapter 16: Sim-to-real transfer techniques","sidebar_position":16},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 15: Reinforcement learning for robot control","permalink":"/docs/part4/chapter-15-rl-control"},"next":{"title":"Chapter 17: Kinematics & Dynamics","permalink":"/docs/part5/chapter-17-kinematics-dynamics"}}');var i=t(4848),o=t(8453);const s={sidebar_label:"Chapter 16: Sim-to-real transfer techniques",sidebar_position:16},a="Chapter 16: Sim-to-Real Transfer Techniques",l={},d=[{value:"The Reality Gap",id:"the-reality-gap",level:2},{value:"Domain Randomization (DR)",id:"domain-randomization-dr",level:2},{value:"Types of Randomization",id:"types-of-randomization",level:3},{value:"Code Example: <code>domain_randomization_cfg.py</code>",id:"code-example-domain_randomization_cfgpy",level:3},{value:"System Identification (System ID)",id:"system-identification-system-id",level:2},{value:"Advanced: Actuator Nets",id:"advanced-actuator-nets",level:3},{value:"Deployment",id:"deployment",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"chapter-16-sim-to-real-transfer-techniques",children:"Chapter 16: Sim-to-Real Transfer Techniques"})}),"\n",(0,i.jsx)(n.h2,{id:"the-reality-gap",children:"The Reality Gap"}),"\n",(0,i.jsx)(n.p,{children:'The "Reality Gap" is the infamous drop in performance when an AI model trained in simulation fails in the real world. It stems from two main sources:'}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Dynamics Gap"}),": The physics simulator is an approximation. Real motors have friction, backlash, and heat-based dampening that ",(0,i.jsx)(n.code,{children:"F=ma"})," doesn't perfectly capture. Real floors are uneven; real contacts are soft."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Visual Gap"}),': If using cameras, real light is messy. Shadows, reflections, and "grain" in the image sensor look different from the perfect, crisp renders of Isaac Sim.']}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"domain-randomization-dr",children:"Domain Randomization (DR)"}),"\n",(0,i.jsxs)(n.p,{children:["We cannot model reality perfectly. Instead, we embrace chaos. ",(0,i.jsx)(n.strong,{children:"Domain Randomization"}),' is the technique of varying simulation parameters during training across a wide range. Ideally, the "Real World" becomes just one sample within that distribution.']}),"\n",(0,i.jsx)(n.h3,{id:"types-of-randomization",children:"Types of Randomization"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Physics Randomization"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Mass"}),": Vary robot link mass by \xb110%."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Friction"}),': Change floor friction from "Ice" (0.1) to "Carpet" (1.0).']}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Damping"}),": Add resistance to joints to simulate rusty motors."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Visual Randomization"})," (for camera-based policies):","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Lighting"}),": Randomize position, color, and intensity of lights."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Texture"}),": Swap the floor texture with random images."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Camera Pose"}),": Jitter the camera position slightly to simulate mounting errors."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"code-example-domain_randomization_cfgpy",children:["Code Example: ",(0,i.jsx)(n.code,{children:"domain_randomization_cfg.py"})]}),"\n",(0,i.jsxs)(n.p,{children:["In Isaac Lab, we use the ",(0,i.jsx)(n.code,{children:"EventTermCfg"})," to inject these randomizations into the environment loop."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from isaaclab.managers import EventTermCfg as EventTerm\r\nfrom isaaclab.managers import SceneEntityCfg\r\nimport isaaclab.envs.mdp as mdp\r\n\r\n@configclass\r\nclass EventCfg:\r\n    # 1. Mass Randomization\r\n    # This forces the policy to be robust to weight estimation errors\r\n    add_mass = EventTerm(\r\n        func=mdp.randomize_rigid_body_mass,\r\n        mode="startup", # Apply once when env is created\r\n        params={\r\n            "asset_cfg": SceneEntityCfg("robot", body_names=".*"),\r\n            "mass_distribution_params": (-0.5, 0.5), # Add between -0.5kg and +0.5kg\r\n            "operation": "add"\r\n        }\r\n    )\r\n\r\n    # 2. Friction Randomization\r\n    # Crucial for locomotion - robot must learn not to slip\r\n    physics_material = EventTerm(\r\n        func=mdp.randomize_rigid_body_material,\r\n        mode="startup",\r\n        params={\r\n            "asset_cfg": SceneEntityCfg("robot", body_names=".*"),\r\n            "static_friction_range": (0.4, 1.0),\r\n            "dynamic_friction_range": (0.4, 0.9),\r\n            "restitution_range": (0.0, 0.1), # Bounciness\r\n        }\r\n    )\r\n    \r\n    # 3. Push Randomization\r\n    # Periodically shove the robot to teach it balance recovery\r\n    push_robot = EventTerm(\r\n        func=mdp.push_by_setting_velocity,\r\n        mode="interval", # Apply every N seconds\r\n        interval_range_s=(10.0, 15.0),\r\n        params={\r\n            "velocity_range": {"x": (-0.5, 0.5), "y": (-0.5, 0.5)},\r\n        }\r\n    )\n'})}),"\n",(0,i.jsx)(n.h2,{id:"system-identification-system-id",children:"System Identification (System ID)"}),"\n",(0,i.jsxs)(n.p,{children:['Before randomizing, we need a good "center point." ',(0,i.jsx)(n.strong,{children:"System ID"})," is the process of measuring your real robot to tune the simulation base parameters."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Weigh individual parts"}),": Don't trust the CAD file blindly."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Motor Identification"}),": Record torque-vs-velocity curves on the real motor and fit a curve to match in sim."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Latency Measurement"}),': Measure the time from "Python Command" to "Motor Movement". Add this delay (often 20-50ms) to the simulation step logic.']}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"advanced-actuator-nets",children:"Advanced: Actuator Nets"}),"\n",(0,i.jsxs)(n.p,{children:["For high-performance robots, a simple DC Motor model isn't enough. Researchers often train a small neural network (an ",(0,i.jsx)(n.strong,{children:"Actuator Net"}),") to predict the motor's response to a command, training it on real-world log data. This net is then used inside the simulator as the physics model for the joint."]}),"\n",(0,i.jsx)(n.h2,{id:"deployment",children:"Deployment"}),"\n",(0,i.jsxs)(n.p,{children:["Once trained, you export your policy (usually a small neural network) to a format like ",(0,i.jsx)(n.strong,{children:"ONNX"})," or ",(0,i.jsx)(n.strong,{children:"TorchScript"}),". This file is loaded onto the real robot's onboard computer (e.g., Jetson Orin)."]}),"\n",(0,i.jsx)(n.p,{children:"The real robot code runs a simple loop:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Read Sensors"}),": Get current Joint Positions (q) and Velocities (dq)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Normalize Data"}),": Apply the exact same scaling/normalization you used in ",(0,i.jsx)(n.code,{children:"ObservationManager"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Run Inference"}),": Pass the normalized vector to the ONNX model."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Scale Output"}),": Convert the raw neural net output [-1, 1] to Torque commands [Nm]."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Safety Filter"}),": Clip the commands to safe limits (e.g., max torque, max velocity) to prevent hardware damage if the policy hallucinates."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Send to Motors"}),": Dispatch the command over CAN bus or EtherCAT."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"If your Domain Randomization was sufficient, the robot should behave similarly to how it did in Isaac Sim!"})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453(e,n,t){t.d(n,{R:()=>s,x:()=>a});var r=t(6540);const i={},o=r.createContext(i);function s(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);